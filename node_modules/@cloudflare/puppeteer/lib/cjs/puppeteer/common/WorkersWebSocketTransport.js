"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkersWebSocketTransport = void 0;
const chunking_js_1 = require("./chunking.js");
class WorkersWebSocketTransport {
    constructor(ws, sessionid) {
        this.chunks = [];
        this.pingInterval = setInterval(() => {
            return this.ws.send('ping');
        }, 1000); // TODO more investigation
        this.ws = ws;
        this.ws.addEventListener('message', event => {
            this.chunks.push(new Uint8Array(event.data));
            const message = (0, chunking_js_1.chunksToMessage)(this.chunks, sessionid);
            if (message && this.onmessage) {
                this.onmessage(message);
            }
        });
        this.ws.addEventListener('close', () => {
            console.log('websocket closed'); // TODO remove
            clearInterval(this.pingInterval);
            if (this.onclose) {
                this.onclose();
            }
        });
        this.ws.addEventListener('error', e => {
            console.error(`Websocket error: SessionID: ${sessionid}`, e);
            clearInterval(this.pingInterval);
        });
    }
    static async create(endpoint, sessionid) {
        const path = `/v1/connectDevtools?browser_session=${sessionid}`;
        const response = await endpoint.fetch(path, {
            headers: { Upgrade: 'websocket' },
        });
        response.webSocket.accept();
        return new WorkersWebSocketTransport(response.webSocket, sessionid);
    }
    send(message) {
        for (const chunk of (0, chunking_js_1.messageToChunks)(message)) {
            this.ws.send(chunk);
        }
    }
    close() {
        console.log('closing websocket'); // TODO remove
        clearInterval(this.pingInterval);
        this.ws.close();
    }
}
exports.WorkersWebSocketTransport = WorkersWebSocketTransport;
//# sourceMappingURL=WorkersWebSocketTransport.js.map